
# Day 1 - Easy
A couple of caveats regarding this exercise:

1. Given the relatively small amount of code, I didn't make a huge effort to utilize classes and methods.
2. It isn't very algorighmically efficient; in fact the iteration process to check for neighboring rolls is of O(n^2) time complexity, so it's not going to scale very well.
3. While I didn't use generative AI in the solution, I did utilize some judicious Googling, which is how I arrived at the use of a mask to check for adjacent neighbors.

So, I come from a background in finite-element analysis, which involves numerically solving huge systems of linear equations, I'm accustomed to using arrays. And if you do much machine learning, you'll encounter things called tensors, which are just multidimensional arrays.

So, when I look at this gridded arrangement of paper rolls, my brain says, "aha, that's an array, and I can represent each roll of paper with a 1 and each blank space with a 0, and to get the number of adjacent rolls around a space, I just sum up all the nearest neighbors.

Now, most languages that are oriented towards numeric computation, such as FORTRAN, MATLAB, Octave, Julia, and even R all have native data types for numeric arrays. Python does not. But NumPy is one of the most commonly-used external libraries for Python, and it has a n-dimensional array data type called ndarray, as well as tools for directly reading a text file into an ndarray, so rather than cook my own logic, I just imported what was already out there.

We begin with the `read_grid_from_file` function, which simply uses NumPy's genfromtxt method to read the data file into an ndarray. Then, as I said, I want to represent each "@" in the array with a 1, so the expression in the return basically does this: For every position in the array, if it is a "@", the expression in the parentheses returns True; else, it returns false. Then, since I now have an array of booleans, the `astype` method casts the booleans to 1 and 0.

Then, we get to the meat of the program, which is where we take that array of 1's and 0's and iterate over each position to sum up the nearest neighbors. We initialize a counter to keep count of all cells that have less than 4 neighbors with a roll of paper.

To actually sum up the neighbors for each cell, we utilize a little trick I found on Google (or maybe it was Stack Overflow): We define a list of ordered pairs, such that each ordered pair represents the relative coordinates for a possible neighbor.

Since we're only interested in calculating the neighbors of cells that have rolls, we first check our current cell to see if it has a roll; if not, we continue on to the next cell.

If it does have a roll, then we iterate over the _relative_ x and y coordinates in the `neighbors` list, and add that to the coordinates of or current cell. When we do so, we check to make sure that the neighbor coordinate does not fall out-of-bounds, because that would throw an exception when we try to reference those coordinates in the next line

Finally, if the cell's sum of all neighbors is < 4, we increment our counter and go on to the next cell. Once we've iterated over all cells, we print the final tally.

As I mentioned, this is not a particularly efficent algorithm. For example, we end up checking each cell's value not just once, but up to 9 times.